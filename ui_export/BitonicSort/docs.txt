Sort k n-bit integers in-place using a Bitonic sorting network.

For a given input list $x_1, x_2, \ldots, x_k$, applies the transform

$$
    |x_1, x_2, \ldots, x_k\rangle \mapsto |y_1, y_2, \ldots, y_k\rangle|\mathsf{junk}\rangle
$$

where $y_1, y_2, \ldots, y_k = \mathrm{sorted}(x_1, x_2, \ldots, x_k)$, and the junk register
stores the result of comparisons done during the sorting. Note that the `junk` register will
be entangled with the input list register.

Currently only supports $k$ being a power of two (#1090).

The bitonic sorting network requires $\frac{k}{2} \frac{\log{k} (1+\log{k})}{2}$ total comparisons,
and has depth $\frac{\log{k} (1+\log{k})}{2}$, when $k$ is a power of 2. Each comparison generates
one ancilla qubit that stores the result of the comparison, so the total size of `junk` register
equals the number of comparisons.

#### Parameters
 - `k`: Number of integers to sort.
 - `bitsize`: number of bits $n$ of each input number. 

#### Registers
 - `xs`: List of k integers we want to sort.
 - `junk`: the generated ancilla qubits of each comparison in the sorting network. 

#### References
 - [Improved techniques for preparing eigenstates of fermionic Hamiltonians](https://www.nature.com/articles/s41534-018-0071-5). Supporting Information Sec. II.

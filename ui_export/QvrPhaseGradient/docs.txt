QVR oracle that applies a rotation via addition into the phase gradient register.

A $b_\text{grad}$-bit phase gradient state $|\phi\rangle_{b_\text{grad}}$ can be written as

$$
\begin{aligned}
|\phi\rangle_{b_\text{grad}} &= \frac{1}{\sqrt{2^{b_\text{grad}}}}
                                \sum_{k=0}^{2^{b_\text{grad}} - 1}
                                e^{\frac{-2\pi i k}{2^{b_\text{grad}}}}
                                |\frac{k}{2^{b_\text{grad}}}\rangle \\
                             &= \text{QVR}_{(b_\text{grad}, b_\text{grad}), \epsilon}(-1)
                                |+\rangle ^ {b_\text{grad}}
\end{aligned}
$$

In the above equation $\frac{k}{2^{b_\text{grad}}}$ represents a fixed point fraction. In
Qualtran, we can represent such a quantum register using quantum data type
`QFxp(bitsize=b_grad, num_frac=b_grad, signed=False)`. Let
$\tilde{k}=\frac{k}{2^{b_\text{grad}}}$ be a $b_\text{grad}$-bit fixed point fraction,
we can rewrite the phase gradient state as


$$
    |\phi\rangle_{b_\text{grad}} = \frac{1}{\sqrt{2^{b_\text{grad}}}}
    \sum_{\tilde{k}=0}^{\frac{2^{b_\text{grad}}-1}{2^{b_\text{grad}}}}
    e^{-2\pi i \tilde{k}} \ket{\tilde{k}}
$$


A useful property of the phase gradient state is that adding a fixed-point number
$\tilde{l}$ to the state applies a phase-kickback of $e^{2\pi i \tilde{l}}$

$$
|\phi + \tilde{l}\rangle_{b_\text{grad}} = e^{2\pi i \tilde{l}}|\phi\rangle_{b_\text{grad}}
$$

We exploit this property of the phase gradient states to implement a quantum variable
rotation via addition into the phase gradient state s.t.

$$\begin{aligned}
    \text{QVR}_{n,\epsilon}(\gamma)|x\rangle|\phi\rangle &=|x\rangle|\phi+\gamma x\rangle \\
                                      &= e^{2\pi i \gamma x}|x\rangle |\phi\rangle
\end{aligned}$$

A number of subtleties arise as part of this procedure and we describe them below one by one.

- **Adding a scaled value into phase gradient register** Instead of computing $\gamma x$ an
    intermediate register, we perform the multiplication via repeated additions into the phase
    gradient register, as described in [2]. This requires us to represent $\gamma$ as a fixed
    point fraction with bitsize $\gamma_\text{bitsize}$. This procedure introduces two sources
    of errors:
    - **Errors due to fixed point representation of $\gamma$** - Note that adding any fixed
        point number of the form $a.b$ to the phase gradient register is equivalent to adding
        $0.b$ since $e^{2\pi i a} = 1$ for every integer $a$. Let $\tilde{\gamma} = a.b$ and
        $x = p.q$ be fixed point decimal representations of $\gamma$ and $x$. We can write
        the product $\gamma x$ as
    $$
          \tilde{\gamma} x = (\sum_{i=0}^{\gamma_\text{n\_int}} a_{i} * 2^{i} +
          \sum_{i=1}^{\gamma_\text{n\_frac}} \frac{b_i}{2^i}) (\sum_{j=0}^{x_\text{n\_int}}
          p_{j} * 2^{j} + \sum_{j=1}^{x_\text{n\_frac}} \frac{q_{j}}{2^{j}})
    $$
    In order to compute $\tilde{\gamma} x$ to precision $\frac{\epsilon}{2\pi}$, we can
    ignore all terms in the above summation that are < $\frac{\epsilon}{2\pi}$.
    Let $b_\text{phase} = \log_2{\frac{2\pi}{\epsilon}}$, then we get
    $\gamma_\text{n\_frac} = x_\text{n\_int} + b_\text{phase}$. Thus,

    $$\begin{aligned}
          \gamma_\text{bitsize} &= \gamma_\text{n\_int} + x_\text{n\_int} + b_\text{phase} \\
                                &\approxeq \log_2{\frac{1}{\epsilon}} + x_\text{n\_int} + O(1)
    \end{aligned}$$

    - **Errors due to truncation of digits of $|x\rangle$ during multiplication via repeated
        addition** - Let $b_\text{grad}$ be the size of the phase gradient register. When
        adding left/right shifted copies of state $x$ to the phase gradient register, we incur
        an error every time the fractional part of the shifted state to be added needs to be
        truncated to $b_\text{grad}$ digits. For each such addition the error is upper bounded
        by $\frac{2\pi}{2^{b_\text{grad}}}$, because we omit adding bits that would correspond
        to phase shifts of $\frac{2\pi}{2^{b_\text{grad}+1}}$, $\frac{2\pi}{2^{b_\text{grad}+2}}$,
        and so forth. The number of such additions can be upper bounded by
        $\frac{(\gamma_\text{bitsize} + 2)}{2}$ using techniques from [2].

      - **When $b_\text{grad} \geq x_\text{bitsize}$**:  the first $x_\text{n\_int}$ additions
        do not contribute to any phase error and thus the number of error causing additions can
        be upper bounded by $\frac{(b_\text{phase} + 2)}{2}$. In order to keep the error less
        than $\epsilon$, we get
        $$\begin{aligned}
        b_\text{grad}&=\left\lceil\log_2{\frac{\text{num\_additions}\times2\pi}{\epsilon}}
                    \right\rceil \\
                    &=\left\lceil\log_2{\frac{(b_\text{phase}+2)\pi}{\epsilon}}\right\rceil
                    \text{; if }
                    b_\text{grad} \geq x_\text{bitsize}  \\
        \end{aligned}$$
      - **When $b_\text{grad} \lt x_\text{bitsize}$**: We believe that the above precision for
        $b_\text{grad}$ holds even for this case we have some numerics in tests to verify that.
        Currently, `QvrPhaseGradient` always sets the bitsize of phase gradient register as per
        the above equation.

- **Constraints on $\gamma$ and $|x\rangle$** - In the current implementation, $\gamma$ can be
    any arbitrary floating point number (signed or unsigned) and $|x\rangle$ must be an unsigned
    fixed point register.

- **Cost of the phase gradient procedure** - Each addition into the phase gradient register
    costs $b_\text{grad} - 2$ Toffoli's and there are $\frac{\gamma_\text{bitsize} + 2}{2}$
    such additions, therefore the total Toffoli cost is

    $$\begin{aligned}
    \text{T-Cost} &= \frac{(b_\text{grad} - 2)(\gamma_\text{bitsize} + 2)}{2} \\
              &\approxeq \mathcal{O}\left(\log^2{\frac{1}{\epsilon}} +
              \log{\left(\frac{1}{\epsilon}\right)}
              \log{\left(\log{\left(\frac{1}{\epsilon}\right)}\right)}\right)
    \end{aligned}$$


Thus, for cases where $-1\lt \gamma \lt 1$ and $0 \leq x \lt 1$, the toffoli cost scales
as $\mathcal{O}\left(\log^2{\frac{1}{\epsilon}} \log{\log{\frac{1}{\epsilon}}}\right)$

#### References
 - [Compilation of Fault-Tolerant Quantum Heuristics for Combinatorial Optimization](https://arxiv.org/abs/2007.07391). Section II-C: Oracles for phasing by cost function. Appendix A: Addition for controlled rotations

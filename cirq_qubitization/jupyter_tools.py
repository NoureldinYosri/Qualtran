import dataclasses
import inspect
import re
from pathlib import Path
from typing import Dict, List, Callable

import IPython.display
import cirq
import cirq.contrib.svg.svg as ccsvg
import ipywidgets
import nbformat
from sphinx.ext.napoleon import Config, GoogleDocstring

import cirq_qubitization.testing as cq_testing
from cirq_qubitization.gate_with_registers import Registers
from cirq_qubitization.jupyter_data import NOTEBOOK_DATA, NotebookData


def display_gate_and_compilation(g: cq_testing.GateHelper, vertical=False):
    """Use ipywidgets to display SVG circuits for a `GateHelper` next to each other.

    Args:
        g: The `GateHelper` to draw
        vertical: If true, lay-out the original gate and its decomposition vertically
            rather than side-by-side.
    """
    out1 = ipywidgets.Output()
    out2 = ipywidgets.Output()
    if vertical:
        box = ipywidgets.VBox([out1, out2])
    else:
        box = ipywidgets.HBox([out1, out2])

    out1.append_display_data(svg_circuit(g.circuit, registers=g.r))
    out2.append_display_data(
        svg_circuit(cirq.Circuit(cirq.decompose_once(g.operation)), registers=g.r)
    )

    IPython.display.display(box)


def svg_circuit(circuit: 'cirq.AbstractCircuit', registers: Registers = None):
    """Return an SVG object representing a circuit.

    Args:
        circuit: The circuit to draw.
        registers: Optional `Registers` object to order the qubits.
    """
    if len(circuit) == 0:
        raise ValueError("Circuit is empty.")

    if registers is not None:
        qubit_order = registers.merge_qubits(**registers.get_named_qubits())
    else:
        qubit_order = cirq.QubitOrder.DEFAULT
    tdd = circuit.to_text_diagram_drawer(transpose=False, qubit_order=qubit_order)
    if len(tdd.horizontal_lines) == 0:
        raise ValueError("No non-empty moments.")
    return IPython.display.SVG(ccsvg.tdd_to_svg(tdd))


class _GoogleDocstringToMarkdown(GoogleDocstring):
    def _parse_parameters_section(self, section):
        lines = ['#### Parameters']
        for _name, _type, _desc in self._consume_fields():
            desc = ' '.join(_desc)
            lines += [f' - `{_name}`: {desc}']

        lines += ['']
        return lines

    def _parse_references_section(self, section):
        lines = self._consume_to_next_section()
        lines = [line.strip() for line in lines]
        return ['#### References', ' '.join(lines), '']


def get_markdown_docstring_lines(cls) -> List[str]:
    """From a class `cls`, return its docstring as Markdown."""
    config = Config()
    gds = _GoogleDocstringToMarkdown(inspect.cleandoc(cls.__doc__),
                                     config=config, what='class')
    lines = [f'## `{cls.__name__}`'] + gds.lines()
    lines = [re.sub(r':py:func:`(\w+)`', r'`\1`', line)
             for line in lines]

    return lines


def _get_lines_for_constructing_an_object(func: Callable):
    """Parse out the source code from a factory function so we can render it into a cell.

    Args:
        func: The factory function. Its definition must be one line; its body must be
            indented with four spaces; and it must end with a top-level return statement that
            is one line.

    Returns:
        trimmed_lines: The un-indented body of the function without the return statement.
        obj_expression: The expression used in the terminal `return` statement.
    """
    def_line, *pre, ret_line = inspect.getsource(func).splitlines()
    assert def_line.startswith('def '), def_line

    trimmed_lines = []
    for line in pre:
        assert line == '' or line.startswith(' ' * 4), line
        trimmed_lines.append(line[4:])
    assert ret_line.startswith('    return '), ret_line
    obj_expression = ret_line[len('    return '):]
    return trimmed_lines, obj_expression


_IMPORTS = """\
import cirq
import numpy as np
import cirq_qubitization
import cirq_qubitization.testing as cq_testing
from cirq_qubitization.jupyter_tools import display_gate_and_compilation
from typing import *\
"""

_GATE_DISPLAY = """\
{lines}
g = cq_testing.GateHelper(
    {obj_expression}
)

display_gate_and_compilation(g{vert_str})\
"""


def _get_gate_construction_lines(gate_func: Callable, vertical: bool) -> str:
    """Render the given factory function into the `_GATE_DISPLAY` template."""
    lines, obj_expression = _get_lines_for_constructing_an_object(gate_func)

    vert_str = ''
    if vertical:
        vert_str = ', vertical=True'

    return _GATE_DISPLAY.format(
        lines='\n'.join(lines),
        obj_expression=obj_expression,
        vert_str=vert_str
    )


_K_CQ_AUTOGEN = 'cq.autogen'
"""The jupyter metadata key we use to identify cells we've autogenerated."""


def _md_cell(source, cqid: str):
    """Helper function to return a markdown cell with correct metadata"""
    return nbformat.v4.new_markdown_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


def _code_cell(source, cqid: str):
    """Helper function to return a code cell with correct metadata"""
    return nbformat.v4.new_code_cell(source, metadata={_K_CQ_AUTOGEN: cqid})


@dataclasses.dataclass
class GateCells:
    """Rendered cells for a gate."""

    md: nbformat.NotebookNode
    py: nbformat.NotebookNode


@dataclasses.dataclass
class NbCells:
    """Rendered notebook cells."""

    title_cell: nbformat.NotebookNode
    top_imports: nbformat.NotebookNode
    gate_cells: Dict[str, GateCells]

    def get_all_cqids(self) -> List[str]:
        """Get all the 'cqid's we know about.

        These are ordered in the way the cells should appear in a rendered notebook.
        It is a flat list that includes both notebook-level cells and all the cqids
        for the `GateCells` in `self.gate_cells`.
        """
        cqids = [
            'title_cell',
            'top_imports',
        ]
        for gate_cqid in self.gate_cells.keys():
            cqids.append(f'{gate_cqid}.md')
            cqids.append(f'{gate_cqid}.py')
        return cqids

    def get_from_cqid(self, cqid: str) -> nbformat.NotebookNode:
        """Look up the cell from its cqid metadata string."""
        if '.' in cqid:
            gate_cqid, ext = cqid.split('.')
            return getattr(self.gate_cells[gate_cqid], ext)

        return getattr(self, cqid)


def render_notebook_cells(nb_data: NotebookData) -> NbCells:
    """Generate cells for a given notebook."""

    nb_cells = NbCells(
        title_cell=_md_cell(f'# {nb_data.title}', 'title_cell'),
        top_imports=_code_cell(_IMPORTS, 'top_imports'),
        gate_cells={},
    )

    for g_data in nb_data.gates:
        gate_obj = g_data.factory()
        gate_cqid = g_data.cqid
        nb_cells.gate_cells[gate_cqid] = GateCells(
            md=_md_cell('\n'.join(
                get_markdown_docstring_lines(cls=gate_obj.__class__)), f'{gate_cqid}.md'),
            py=_code_cell(
                _get_gate_construction_lines(gate_func=g_data.factory,
                                             vertical=g_data.draw_vertical), f'{gate_cqid}.py'),

        )

    return nb_cells


def _init_notebook(modname: str, overwrite=False) -> nbformat.NotebookNode:
    """Initialize a jupyter notebook.

    If one already exists: load it in. Otherwise create a new one.

    Args:
        modname: The name used to find the notebook if it exists.
        overwrite: If set, remove any existing notebook and start from scratch.
    """

    nb_path = Path(f'{modname}.ipynb')

    if overwrite:
        nb_path.unlink(missing_ok=True)

    if nb_path.exists():
        with nb_path.open('r') as f:
            return nbformat.read(f, as_version=4)

    nb = nbformat.v4.new_notebook()
    nb['metadata'].update({
        'kernelspec': {
            'language': 'python',
            'name': 'python3',
            'display_name': 'Python 3',
        },
        'language_info': {
            'name': 'python'
        }
    })
    return nb


def render_notebooks():
    for modname, nb_data in NOTEBOOK_DATA.items():
        # 1. get a notebook (existing or empty)
        nb = _init_notebook(modname=modname)

        # 2. Render all the cells we can render
        cells = render_notebook_cells(nb_data)

        # 3. Merge rendered cells into the existing notebook.
        #     -> we use the cells metadata field to match up cells.
        cqids_to_render = cells.get_all_cqids()
        for i in range(len(nb.cells)):
            cell = nb.cells[i]
            if _K_CQ_AUTOGEN in cell.metadata:
                cqid: str = cell.metadata[_K_CQ_AUTOGEN]
                print(f"[{modname}] Replacing {cqid}")
                new_cell = cells.get_from_cqid(cqid)
                new_cell.id = cell.id  # keep id from existing cell
                nb.cells[i] = new_cell
                cqids_to_render.remove(cqid)

        # 4. Any rendered cells that weren't already there, append.
        for cqid in cqids_to_render:
            print(f"[{modname}] Adding {cqid}")
            new_cell = cells.get_from_cqid(cqid)
            nb.cells.append(new_cell)

        # 5. Write the notebook.
        with open(f'{modname}.ipynb', 'w') as f:
            nbformat.write(nb, f)


if __name__ == '__main__':
    render_notebooks()
